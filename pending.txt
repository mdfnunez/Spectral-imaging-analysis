Antes de volcar tus datos ya demosaizados a TIFF conviene aplicar todas las correcciones que la XML de calibración te proporciona, para que tus “canales” pasen de simples valores crudos (DN) a unidades fisico-radiométricas o, incluso, a bandas espectrales “virtuales” ordenadas por longitud de onda. A grandes rasgos, los pasos son:

1. **Corrección de ganancia y offset (sensor\_info)**
   En `<sensor_info>` encontrarás parámetros como `<overall_gain>`, `<analog_gain>` y `<digital_gain>`. Con ellos conviertes tus DN (uint16) en electrones o en una unidad linealmente proporcional a la radiancia de entrada .

   ```python
   # Ejemplo conceptual (aplicar tras cargar img como float32):
   img_physical = img * overall_gain * analog_gain * digital_gain
   ```

2. **Sustracción de “dark current” y división por “white reference” (flat-field)**
   Si tienes mediciones de “dark” (cámara tapada) y “white” (cartón gris/objetivo uniforme), calcula:

   $$
     R_{\rm raw} = \frac{\rm img - dark}{white - dark}
   $$

   Con ello corriges vignetting y patrones de pixel a pixel.

3. **Corrección espectral por responsividad (filter\_info → calibration\_info)**
   En `<calibration_info>` hay un vector `sample_points_nm` (p. ej. 400–700 nm) y en cada `<band>` una curva `response` de responsividad sobre esos puntos . Debes dividir cada canal de tu cubo `(h×w×16)` por el valor de responsividad correspondiente a esa banda:

   ```python
   # C carga tu array (16, N_muestras) de responsividades
   for b in range(16):
       cube[:,:,b] /= responsivity[b].max()   # o interpola si hiciera falta
   ```

4. **(Opcional) Aplicar la matriz de corrección espectral → “bandas virtuales”**
   En `<spectral_correction_info><correction_matrices><virtual_bands>` tienes una matriz 16×16 de coeficientes que mezcla tus canales “sensor” (ordenados por posición física) en 16 “bandas virtuales” ordenadas por longitud de onda . Se hace con un simple producto matricial por píxel:

   ```python
   # SS: vector de 16 reflectancias crudas por píxel (shape=(16,))
   # C: matriz (16,16) extraída de los <coefficients>
   CS = C @ SS  # → vector de 16 bandas virtuales ordenadas por λ creciente
   ```

5. **Conversión a unidades finales y guardado a TIFF**
   Una vez tengas tu cubo ya en reflectancia (o radiancia), puedes reescalar al rango que necesites (por ejemplo 0–1 o 16 bits), transponer a `(bands, rows, cols)` y volcarlo con TIFF usando `tifffile.imwrite`.

---

**En resumen**, antes de pasar a TIFF:

* **Aplica** las ganancias del sensor (`overall_gain`, etc.) para convertir DN→unidades físicas.
* **Corrige** dark-current y flat-field con tus propias imágenes de referencia.
* **Divide** por la curva de responsividad de cada banda (`<response>`).
* **(Opcional)** Multiplica por la matriz de corrección para obtener bandas virtuales ordenadas por longitud de onda.

Solo **después** de estos pasos tu cubo estará correctamente calibrado y listo para persistir como TIFF.
